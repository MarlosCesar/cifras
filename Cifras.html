<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Seletor de Cifras</title>
  
  <link rel="preload" href="https://cdn.tailwindcss.com" as="script">
  
  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

  <script src="https://cdn.tailwindcss.com"></script>
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <style>
    /* Variáveis CSS para um tema mais profissional e fácil manutenção */
    :root {
      --primary-color: #3b82f6; /* Azul primário */
      --primary-dark: #2563eb; /* Azul mais escuro para hover/ativo */
      --primary-hover: #e0e7ff; /* Azul muito claro para fundo de hover */
      --danger-color: #ef4444; /* Vermelho para ações perigosas */
      --danger-dark: #dc2626; /* Vermelho mais escuro */
      --gray-light: #f3f4f6; /* Cinza claro para o background geral */
      --gray-medium: #e5e7eb; /* Cinza médio para bordas/divisores */
      --text-color-dark: #333333; /* Texto escuro quase preto */
      --text-color-light: #4b5563; /* Texto cinza escuro */
      --shadow-base: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-primary: 0 0 10px rgba(37, 99, 235, 0.3);

      /* Cores do cabeçalho */
      --header-bg: #1A202C; /* Cinza bem escuro para o cabeçalho */
      --header-text: #E2E8F0; /* Cinza claro para o texto do cabeçalho */
      --header-hover: #2D3748; /* Tom um pouco mais claro para hover dos botões do cabeçalho */
    }

    html, body {
      /* Garante que o overflow-x seja escondido para evitar barras de rolagem horizontais em mobile */
      overflow-x: hidden; 
      overflow-y: auto;
      background-color: var(--gray-light);
      font-family: 'Inter', sans-serif; /* Usando a fonte Inter */
      color: var(--text-color-dark); /* Cor de texto padrão */
    }

    /* Estilo do cabeçalho profissional */
    .header-professional {
      background-color: var(--header-bg);
      color: var(--header-text);
      box-shadow: var(--shadow-base); /* Sombra suave para o cabeçalho */
    }

    .header-professional button {
      transition: background-color 0.3s ease, transform 0.1s ease; /* Transição suave e pequena escala no clique */
      display: flex; /* Para alinhar ícone e texto se houver */
      align-items: center;
      justify-content: center;
    }

    .header-professional button:hover {
      background-color: var(--header-hover);
    }

    .header-professional button:active {
        transform: scale(0.98); /* Pequeno efeito de clique */
    }

    /* Estilos para as abas */
    .tabs {
      display: flex;
      gap: 0.5rem;
      border-bottom: 2px solid var(--gray-medium); /* Borda inferior para separar as abas do conteúdo */
      margin-bottom: 1rem;
      flex-wrap: wrap; /* Permite que as abas quebrem a linha em telas menores */
      padding: 0 1rem; /* Padding horizontal para não colar nas bordas em mobile */
    }

    .tab {
      padding: 0.65rem 1.2rem; /* Um pouco mais de padding */
      cursor: pointer;
      border-radius: 0.5rem 0.5rem 0 0;
      background-color: #f9fafb;
      border: 1px solid transparent;
      border-bottom: 2px solid transparent;
      transition: all 0.2s ease;
      outline-offset: 2px;
      color: var(--text-color-light); /* Cor do texto das abas não selecionadas */
      font-weight: 500; /* Um pouco mais de peso */
    }

    [role="tab"] {
      user-select: none;
    }

    .tab:hover,
    .tab:focus-visible {
      background-color: var(--primary-hover);
      border-color: var(--primary-color) transparent transparent;
      outline: none;
      color: var(--primary-dark);
    }

    .tab.active {
      background-color: white;
      border-color: var(--primary-color) var(--primary-color) white;
      font-weight: 600;
      color: var(--primary-dark);
      box-shadow: 0 -2px 5px rgba(0,0,0,0.05); /* Sombra sutil na aba ativa */
    }

    /* Estilo para o contêiner de imagem individual */
    .image-container {
      display: flex;
      align-items: center;
      gap: 12px; /* Aumentei o espaçamento entre imagem e nome */
      padding: 12px; /* Mais padding interno */
      border: 1px solid var(--gray-medium); /* Borda sutil */
      border-radius: 0.75rem; /* Bordas mais arredondadas */
      overflow: hidden;
      cursor: pointer; /* Cursor padrão de clique para seleção */
      transition: all 0.2s ease;
      background-color: white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05); /* Sombra mais sutil por padrão */
    }

    .image-container:focus-visible {
      outline: 2px solid var(--primary-color);
      outline-offset: 3px; /* Aumentei o offset para melhor visibilidade */
    }

    .image-container.selected {
      border-color: var(--primary-dark);
      box-shadow: var(--shadow-primary); /* Sombra primária quando selecionado */
      background-color: var(--primary-hover); /* Fundo levemente azulado quando selecionado */
    }

    /* Esconde o checkbox por padrão */
    .image-container .checkbox-wrapper {
        display: none;
        margin-right: 1rem; /* Espaçamento entre o checkbox e a imagem/nome */
    }

    /* Mostra o checkbox quando a seleção está ativa */
    .selection-active .image-container .checkbox-wrapper {
        display: flex; /* Usa flexbox para centralizar o checkbox */
        align-items: center;
    }

    /* Estilos para drag-and-drop */
    .drag-over {
      border: 2px dashed var(--primary-dark) !important; /* Borda mais visível para drag-over */
      background-color: rgba(59, 130, 246, 0.1) !important; /* Fundo levemente azulado */
    }

    .image-container.dragging {
      opacity: 0.4; /* Reduz a opacidade para indicar que está sendo arrastado */
      transform: scale(0.98); /* Pequeno encolhimento visual */
    }

    .image-container img {
      width: 2.2cm; /* Ligeiramente maior */
      height: 3.3cm; /* Ligeiramente maior */
      object-fit: cover;
      border-radius: 0.35rem; /* Bordas um pouco mais arredondadas */
      flex-shrink: 0;
      box-shadow: 0 1px 4px rgba(0,0,0,0.1); /* Sombra sutil na imagem miniatura */
    }

    .image-name {
      font-size: 0.95rem; /* Aumentei ligeiramente o tamanho da fonte */
      color: var(--text-color-dark);
      flex-grow: 1; /* Permite que o nome ocupe o espaço restante */
      overflow-wrap: break-word; /* Garante que nomes longos quebrem a linha */
      word-break: break-word; /* Para compatibilidade */
      max-width: calc(100% - 2.2cm - 12px - 2rem); /* Ajusta a largura máxima para o nome, considerando a imagem, o gap e o checkbox (se visível) */
      line-height: 1.4; /* Melhor espaçamento entre linhas */
    }

    /* Estilo para a visualização em tela cheia */
    .fullscreen-image {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(0, 0, 0, 0.95); /* Fundo mais escuro */
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: zoom-out;
      z-index: 9999;
      touch-action: none; /* Desabilita o scroll padrão da tela */
    }

    .fullscreen-image img {
      max-width: 95%; /* Aumenta o max-width para telas maiores */
      max-height: 95%; /* Aumenta o max-height para telas maiores */
      object-fit: contain;
      transition: transform 0.25s ease;
      border-radius: 0.75rem; /* Bordas mais arredondadas */
      box-shadow: 0 0 25px rgba(0,0,0,0.8); /* Sombra mais pronunciada */
      transform-origin: center center;
    }

    .fullscreen-controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px; /* Aumentei o espaçamento entre os botões */
      background: rgba(0,0,0,0.7);
      padding: 12px 20px; /* Mais padding */
      border-radius: 8px; /* Bordas arredondadas */
    }

    .zoom-btn {
      background: rgba(255,255,255,0.2);
      color: white;
      border: none;
      width: 50px; /* Maior para facilitar o toque em mobile */
      height: 50px; /* Maior para facilitar o toque em mobile */
      border-radius: 50%;
      font-size: 24px; /* Ícone maior */
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.3s ease, transform 0.1s ease;
    }

    .zoom-btn:hover {
      background: rgba(255,255,255,0.3);
    }

    .zoom-btn:active {
        transform: scale(0.95); /* Efeito de clique */
    }

    /* Loading Spinner */
    .loading-spinner {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0,0,0,0.6);
      padding: 20px;
      border-radius: 12px;
      z-index: 10000;
      color: white; /* Cor do spinner e do fundo */
    }

    .loading-spinner.active {
      display: flex; /* Usar flexbox para centralizar o ícone */
      align-items: center;
      justify-content: center;
    }

    /* Mensagem de status */
    #status-message {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
      pointer-events: none; /* Permite cliques através da mensagem */
      text-align: center;
    }

    #status-message.show {
      opacity: 1;
    }

    /* Esconde a seção de seleção por padrão */
    .selection-controls {
        display: none;
    }

    /* Mostra a seção de seleção quando a seleção está ativa */
    .selection-active .selection-controls {
        display: flex;
    }

    /* Media Queries para responsividade */
    @media (max-width: 640px) { /* Pequenas telas (mobile) */
      .header-professional h1 {
        font-size: 1.5rem; /* Ajusta o tamanho do título em mobile */
      }
      .header-professional .space-x-4 {
        gap: 0.5rem; /* Ajusta o espaçamento dos botões do cabeçalho */
      }
      .header-professional button {
        padding: 0.6rem; /* Ajusta o padding dos botões do cabeçalho */
      }

      .tabs {
        flex-wrap: wrap; /* Garante que as abas quebrem em múltiplas linhas */
        justify-content: center; /* Centraliza as abas */
        gap: 0.35rem; /* Espaçamento menor entre as abas */
        padding: 0 0.5rem;
      }
      .tab {
        padding: 0.5rem 0.8rem; /* Padding menor para as abas */
        font-size: 0.9rem; /* Fonte menor para as abas */
      }

      .main-content-area { /* Nova classe para o main container */
        padding: 0.75rem; /* Menor padding para o conteúdo principal */
      }

      /* Image container em mobile */
      .image-container {
        flex-direction: row; /* Mantém a imagem e o nome na mesma linha */
        align-items: center;
        gap: 10px;
        padding: 10px;
      }

      .image-container img {
        width: 1.8cm; /* Miniatura um pouco menor em mobile */
        height: 2.7cm;
      }

      .image-name {
        font-size: 0.875rem; /* Fonte menor para o nome da imagem */
        max-width: calc(100% - 1.8cm - 10px - 2rem); /* Ajusta max-width */
      }

      .flex-wrap.gap-2 { /* Botões "Buscar Local" e "Buscar em Nuvem" */
        flex-direction: column; /* Empilha os botões verticalmente em telas pequenas */
        width: 100%; /* Ocupa a largura total */
      }
      .flex-wrap.gap-2 button {
        width: 100%; /* Faz com que os botões ocupem a largura total */
        justify-content: center; /* Centraliza o texto/ícone nos botões */
      }
      .flex-wrap.gap-2 button i {
        margin-right: 0.5rem; /* Adiciona espaçamento entre o ícone e o texto */
      }

      .fullscreen-controls {
          flex-direction: row; /* Mantém os botões de zoom na mesma linha */
          gap: 10px;
          padding: 10px 15px;
      }
      .zoom-btn {
          width: 45px;
          height: 45px;
          font-size: 22px;
      }
    }

    @media (min-width: 641px) and (max-width: 1024px) { /* Telas médias (tablets) */
        .tabs {
            justify-content: flex-start; /* Alinha as abas à esquerda */
            padding: 0 1.5rem;
        }
        .tab {
            padding: 0.6rem 1.1rem;
            font-size: 0.95rem;
        }
        .image-container {
            padding: 10px;
            gap: 10px;
        }
        .image-container img {
            width: 2cm;
            height: 3cm;
        }
        .image-name {
            font-size: 0.9rem;
            max-width: calc(100% - 2cm - 10px - 2rem);
        }
    }
  </style>
</head>
<body class="bg-gray-100 font-sans antialiased">
  <header class="header-professional p-4">
    <div class="container mx-auto flex justify-between items-center">
      <h1 class="text-2xl font-semibold tracking-wide">Seletor de Cifras</h1>
      <div class="flex items-center space-x-4">
        <button id="sync-btn" class="p-2 rounded-full" aria-label="Sincronizar" title="Sincronizar">
          <i class="fas fa-sync-alt text-lg" aria-hidden="true"></i>
        </button>
        <button id="settings-btn" class="p-2 rounded-full" aria-label="Configurações" title="Configurações">
          <i class="fas fa-cog text-lg" aria-hidden="true"></i>
        </button>
      </div>
    </div>
  </header>

  <main class="container mx-auto p-4 flex flex-col gap-4 main-content-area" role="main">
    <section class="w-full bg-white rounded-xl shadow-md overflow-hidden flex flex-col" aria-label="Seletor de músicas e imagens">
      <div class="p-4 bg-gray-50 border-b flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
        <h2 class="font-semibold text-xl text-gray-700">Minhas Cifras</h2>
        <div class="flex flex-wrap gap-2 justify-end">
          <button id="open-cloud-folder" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition flex items-center" aria-label="Buscar cifras na nuvem (OneDrive)" title="Buscar cifras na nuvem (OneDrive)">
            <i class="fas fa-cloud mr-2" aria-hidden="true"></i> Buscar em Nuvem
          </button>
          <button id="open-file-dialog" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition flex items-center" aria-label="Buscar cifras localmente" title="Buscar cifras localmente">
            <i class="fas fa-folder-open mr-2" aria-hidden="true"></i> Buscar Local
          </button>
          <input type="file" id="file-input" class="hidden" accept="image/*" multiple aria-hidden="true" tabindex="-1" />
        </div>
      </div>

      <nav class="tabs" id="tabs-container" role="tablist" aria-label="Abas das categorias de cifras">
        </nav>

      <div class="p-4 flex flex-col gap-4 flex-1">
        <div class="flex flex-wrap items-center gap-4 mb-2 selection-controls">
          <label class="inline-flex items-center gap-2 cursor-pointer text-gray-700 font-medium" for="select-all">
            <input type="checkbox" id="select-all" class="form-checkbox h-5 w-5 text-blue-600 rounded focus:ring-blue-500" aria-label="Selecionar todas as imagens" />
            <span>Selecionar todas</span>
          </label>
          <button id="clear-selection-btn" class="bg-gray-400 text-white px-4 py-2 rounded-lg hover:bg-gray-500 transition disabled:opacity-50 disabled:cursor-not-allowed flex items-center" disabled aria-disabled="true" aria-label="Limpar seleção">
            <i class="fas fa-undo mr-2" aria-hidden="true"></i> Limpar seleção
          </button>
          <button id="delete-selected-btn" class="bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 transition disabled:opacity-50 disabled:cursor-not-allowed flex items-center" disabled aria-disabled="true" aria-label="Excluir imagens selecionadas">
            <i class="fas fa-trash-alt mr-2" aria-hidden="true"></i> Excluir selecionadas
          </button>
        </div>

        <div id="image-list" class="flex flex-col gap-4" aria-live="polite" aria-atomic="true">
          <p class="text-center text-gray-500 py-8">Nenhuma imagem encontrada nesta categoria.</p>
        </div>
      </div>
    </section>
  </main>

  <div id="loading-spinner" class="loading-spinner">
    <i class="fas fa-spinner fa-spin fa-3x text-blue-600" aria-hidden="true"></i>
    <span class="sr-only">Carregando...</span>
  </div>

  <div id="status-message" aria-live="polite"></div>

  <script>
    // Cache de elementos DOM
    const DOM = {
      tabsContainer: document.getElementById('tabs-container'),
      imageList: document.getElementById('image-list'),
      fileInput: document.getElementById('file-input'),
      openFileDialogButton: document.getElementById('open-file-dialog'),
      openCloudFolderButton: document.getElementById('open-cloud-folder'),
      selectAllCheckbox: document.getElementById('select-all'),
      deleteSelectedBtn: document.getElementById('delete-selected-btn'),
      clearSelectionBtn: document.getElementById('clear-selection-btn'),
      syncBtn: document.getElementById('sync-btn'),
      settingsBtn: document.getElementById('settings-btn'),
      loadingSpinner: document.getElementById('loading-spinner'),
      statusMessage: document.getElementById('status-message'),
      selectionControls: document.querySelector('.selection-controls')
    };

    // Abas desejadas
    const tabs = ["Domingo Manhã", "Domingo Noite", "Segunda", "Quarta", "Culto Jovem", "Santa Ceia", "Outros"];

    // URL da pasta do OneDrive
    const ONE_DRIVE_FOLDER_URL = "https://1drv.ms/f/c/a71268bf66931c02/EpYyUsypAQhGgpWC9YuvE54BD_o9NX9tRar0piSzq4V4Xg"; // Seu link original

    // Estado otimizado com Map/Set
    let imageGalleryByTab = new Map(); // Armazena APENAS os nomes das imagens por aba
    let selectedImagesByTab = new Map();
    let currentTab = tabs[0];
    let dragStartIndex = null;
    let longPressTimer = null; // Para detectar o "pressionar e segurar"
    let isSelectingMode = false; // Novo estado para controlar o modo de seleção

    // Inicializar estado
    tabs.forEach(tab => {
      imageGalleryByTab.set(tab, []);
      selectedImagesByTab.set(tab, new Set());
    });

    // Funções utilitárias
    const Utils = {
      removeFileExtension: filename => filename.replace(/\.[^/.]+$/, ""),
      showStatus: message => {
        DOM.statusMessage.textContent = message;
        DOM.statusMessage.classList.add('show');
        setTimeout(() => DOM.statusMessage.classList.remove('show'), 3000);
      },
      debounce: (func, timeout = 100) => {
        let timer;
        return (...args) => {
          clearTimeout(timer);
          timer = setTimeout(() => { func.apply(this, args); }, timeout);
        };
      },
      // Cache para Object URLs criados a partir de Blobs (para revogar depois)
      objectURLCache: new Map(),
      revokeObjectURL: (url) => {
          if (Utils.objectURLCache.has(url)) {
              URL.revokeObjectURL(url);
              Utils.objectURLCache.delete(url);
          }
      },
      createObjectURL: (blob) => {
          const url = URL.createObjectURL(blob);
          Utils.objectURLCache.set(url, true); // Adiciona ao cache para revogação
          return url;
      }
    };

    // --- IndexedDB Manager ---
    const DB_NAME = 'ImageSelectorDB';
    const DB_VERSION = 2;
    const STORE_IMAGES = 'images';
    const STORE_METADATA = 'metadata';

    const IndexedDBManager = {
      db: null,

      open: () => new Promise((resolve, reject) => {
        if (IndexedDBManager.db) {
            resolve(IndexedDBManager.db);
            return;
        }

        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_IMAGES)) {
            db.createObjectStore(STORE_IMAGES, { keyPath: 'name' });
          }
          if (!db.objectStoreNames.contains(STORE_METADATA)) {
            db.createObjectStore(STORE_METADATA, { keyPath: 'id' });
          }
        };

        request.onsuccess = (event) => {
          IndexedDBManager.db = event.target.result;
          resolve(IndexedDBManager.db);
        };

        request.onerror = (event) => {
          console.error('IndexedDB error:', event.target.errorCode);
          reject(event.target.errorCode);
        };
      }),

      addImageBlob: (imageName, blob) => new Promise(async (resolve, reject) => {
        try {
          const db = await IndexedDBManager.open();
          const transaction = db.transaction([STORE_IMAGES], 'readwrite');
          const store = transaction.objectStore(STORE_IMAGES);
          const request = store.put({ name: imageName, blob: blob });

          request.onsuccess = () => resolve();
          request.onerror = (event) => reject(event.target.error);
        } catch (e) {
          reject(e);
        }
      }),

      getImageBlob: (imageName) => new Promise(async (resolve, reject) => {
        try {
          const db = await IndexedDBManager.open();
          const transaction = db.transaction([STORE_IMAGES], 'readonly');
          const store = transaction.objectStore(STORE_IMAGES);
          const request = store.get(imageName);

          request.onsuccess = (event) => resolve(event.target.result ? event.target.result.blob : null);
          request.onerror = (event) => reject(event.target.error);
        } catch (e) {
          reject(e);
        }
      }),

      deleteImageBlob: (imageName) => new Promise(async (resolve, reject) => {
        try {
          const db = await IndexedDBManager.open();
          const transaction = db.transaction([STORE_IMAGES], 'readwrite');
          const store = transaction.objectStore(STORE_IMAGES);
          const request = store.delete(imageName);

          request.onsuccess = () => resolve();
          request.onerror = (event) => reject(event.target.error);
        } catch (e) {
          reject(e);
        }
      }),

      getAllImageNames: () => new Promise(async (resolve, reject) => {
          try {
              const db = await IndexedDBManager.open();
              const transaction = db.transaction([STORE_IMAGES], 'readonly');
              const store = db.transaction(STORE_IMAGES, 'readonly').objectStore(STORE_IMAGES);
              const request = store.getAllKeys();

              request.onsuccess = (event) => resolve(event.target.result);
              request.onerror = (event) => reject(event.target.error);
          } catch (e) {
              reject(e);
          }
      }),

      saveMetadata: (state) => new Promise(async (resolve, reject) => {
        try {
          const db = await IndexedDBManager.open();
          const transaction = db.transaction([STORE_METADATA], 'readwrite');
          const store = transaction.objectStore(STORE_METADATA);
          const request = store.put({ id: 'appState', state: state });

          request.onsuccess = () => resolve();
          request.onerror = (event) => reject(event.target.error);
        } catch (e) {
          reject(e);
        }
      }),

      loadMetadata: () => new Promise(async (resolve, reject) => {
        try {
          const db = await IndexedDBManager.open();
          const transaction = db.transaction([STORE_METADATA], 'readonly');
          const store = transaction.objectStore(STORE_METADATA);
          const request = store.get('appState');

          request.onsuccess = (event) => resolve(event.target.result ? event.target.result.state : null);
          request.onerror = (event) => reject(event.target.error);
        } catch (e) {
          reject(e);
        }
      })
    };

    // Processamento de imagens
    const ImageProcessor = {
      processImageFile: file => new Promise((resolve, reject) => {
        const img = new Image();
        const url = Utils.createObjectURL(file);

        img.onload = () => {
          const canvas = document.createElement('canvas');
          const MAX_SIZE = 800; // Define um tamanho máximo para a maior dimensão da imagem
          let width = img.width;
          let height = img.height;

          // Redimensiona se a imagem for maior que o MAX_SIZE, mantendo a proporção
          if (width > height) {
            if (width > MAX_SIZE) {
              height *= MAX_SIZE / width;
              width = MAX_SIZE;
            }
          } else {
            if (height > MAX_SIZE) {
              width *= MAX_SIZE / height;
              height = MAX_SIZE;
            }
          }

          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, width, height);

          // Converte para WebP com compressão de 75% para melhor performance e qualidade
          canvas.toBlob(blob => {
            Utils.revokeObjectURL(url); // Libera o Object URL da imagem original
            if (blob) {
                resolve({
                    name: file.name,
                    blob: blob
                });
            } else {
                reject(new Error('Falha ao criar Blob da imagem.'));
            }
          }, 'image/webp', 0.75);
        };

        img.onerror = () => {
          Utils.revokeObjectURL(url); // Libera o Object URL em caso de erro
          reject(new Error('Erro ao carregar a imagem para processamento.'));
        };

        img.src = url;
      })
    };

    // Gerenciamento de estado
    const StateManager = {
        saveState: Utils.debounce(async () => {
            const state = {
                images: Object.fromEntries(Array.from(imageGalleryByTab.entries()).map(([tab, names]) => [tab, Array.from(names)])),
                selected: Object.fromEntries(Array.from(selectedImagesByTab.entries()).map(([tab, set]) => [tab, Array.from(set)])),
                currentTab,
            };
            try {
                await IndexedDBManager.saveMetadata(state);
            } catch (e) {
                console.error('Erro ao salvar estado no IndexedDB:', e);
                Utils.showStatus('Erro ao salvar dados.');
            }
        }, 500),

        loadState: async () => {
            try {
                const state = await IndexedDBManager.loadMetadata();
                if (state) {
                    // Reconstroi os Maps a partir dos objetos planos
                    imageGalleryByTab = new Map(Object.entries(state.images || {}));
                    selectedImagesByTab = new Map();
                    for (const tab of tabs) {
                        selectedImagesByTab.set(tab, new Set(state.selected?.[tab] || []));
                    }
                    currentTab = state.currentTab || tabs[0];
                } else {
                    StateManager.initEmptyState();
                }
            } catch (e) {
                console.error('Erro ao carregar estado do IndexedDB:', e);
                StateManager.initEmptyState();
            }
        },

        initEmptyState: () => {
            imageGalleryByTab = new Map();
            selectedImagesByTab = new Map();
            tabs.forEach(tab => {
                imageGalleryByTab.set(tab, []);
                selectedImagesByTab.set(tab, new Set());
            });
        }
    };

    // Interface do usuário
    const UI = {
      showLoading: () => DOM.loadingSpinner.classList.add('active'),
      hideLoading: () => DOM.loadingSpinner.classList.remove('active'),

      createTabs: () => {
        DOM.tabsContainer.innerHTML = '';
        const fragment = document.createDocumentFragment();

        tabs.forEach((tab, index) => {
          const tabBtn = document.createElement('button');
          tabBtn.className = 'tab';
          tabBtn.setAttribute('role', 'tab');
          tabBtn.setAttribute('tabindex', index === 0 ? '0' : '-1');
          tabBtn.setAttribute('aria-selected', index === 0 ? 'true' : 'false');
          tabBtn.id = `tab-${tab.replace(/\s+/g, '-').toLowerCase()}`; // ID único para a aba
          tabBtn.textContent = tab;

          tabBtn.addEventListener('click', () => TabManager.switchTab(tab));
          tabBtn.addEventListener('keydown', (e) => {
            // Navegação por teclado entre as abas
            const currentActiveIndex = tabs.indexOf(currentTab);
            let nextIndex = currentActiveIndex;

            if (e.key === 'ArrowRight') {
              nextIndex = (currentActiveIndex + 1) % tabs.length;
            } else if (e.key === 'ArrowLeft') {
              nextIndex = (currentActiveIndex - 1 + tabs.length) % tabs.length;
            } else if (e.key === 'Home') {
              nextIndex = 0;
            } else if (e.key === 'End') {
              nextIndex = tabs.length - 1;
            }

            if (nextIndex !== currentActiveIndex) {
              e.preventDefault();
              TabManager.switchTab(tabs[nextIndex]);
              DOM.tabsContainer.querySelector(`#tab-${tabs[nextIndex].replace(/\s+/g, '-').toLowerCase()}`).focus();
            } else if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              TabManager.switchTab(tab);
            }
          });

          fragment.appendChild(tabBtn);
        });

        DOM.tabsContainer.appendChild(fragment);
      },

      updateTabsUI: () => {
        const buttons = DOM.tabsContainer.querySelectorAll('.tab');
        buttons.forEach(btn => {
          const isActive = btn.textContent === currentTab;
          btn.classList.toggle('active', isActive);
          btn.setAttribute('aria-selected', isActive);
          btn.setAttribute('tabindex', isActive ? '0' : '-1'); // Apenas a aba ativa é tab-focável
        });
      },

      renderImages: async () => {
        // Revoga Object URLs antigos para liberar memória
        DOM.imageList.querySelectorAll('img[data-object-url]').forEach(img => {
            Utils.revokeObjectURL(img.dataset.objectUrl);
        });

        const imageNames = imageGalleryByTab.get(currentTab) || [];
        const fragment = document.createDocumentFragment();

        if (imageNames.length === 0) {
          const p = document.createElement('p');
          p.className = 'text-center text-gray-500 py-8'; // Centralizado, sem col-span-full porque agora é flex-col
          p.textContent = 'Nenhuma imagem encontrada nesta categoria.';
          fragment.appendChild(p);
        } else {
          // Garante que o checkbox de "Selecionar todas" está sempre habilitado se houver imagens
          DOM.selectAllCheckbox.disabled = false; 

          // Processa as imagens em lotes ou de forma assíncrona para não travar a UI
          const imagesToRender = [];
          for (const imageName of imageNames) {
            const blob = await IndexedDBManager.getImageBlob(imageName);
            if (blob) {
                imagesToRender.push({ name: imageName, blob: blob });
            } else {
                console.warn(`Imagem ${imageName} não encontrada no IndexedDB. Removendo da lista.`);
                // Remove a imagem do estado se o blob não for encontrado
                imageGalleryByTab.set(currentTab, imageNames.filter(name => name !== imageName));
                selectedImagesByTab.get(currentTab).delete(imageName); // Garante que também é removida da seleção
            }
          }

          imagesToRender.forEach(({ name, blob }) => {
            const container = UI.createImageElement(name, blob);
            fragment.appendChild(container);
          });
        }

        DOM.imageList.innerHTML = '';
        DOM.imageList.appendChild(fragment);
        UI.updateSelectAllCheckbox();
        UI.updateSelectionControlsVisibility(); // Atualiza a visibilidade dos controles de seleção
        UI.updateButtonsState();
      },

      createImageElement: (imageName, imageBlob) => {
        const container = document.createElement('div');
        container.className = 'image-container'; // Classe base
        container.setAttribute('draggable', 'true');
        container.setAttribute('tabindex', '0'); // Torna o container focável
        container.dataset.name = imageName; // Armazena o nome da imagem

        // Checkbox para seleção (inicialmente escondido)
        const checkboxWrapper = document.createElement('label');
        checkboxWrapper.className = 'flex items-center cursor-pointer checkbox-wrapper'; // Adicionado 'checkbox-wrapper'
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'form-checkbox h-5 w-5 text-blue-600 rounded focus:ring-blue-500';
        checkbox.setAttribute('aria-label', `Selecionar ${Utils.removeFileExtension(imageName)}`);
        checkbox.checked = selectedImagesByTab.get(currentTab).has(imageName);
        checkbox.addEventListener('change', (e) => {
            e.stopPropagation(); // Previne que o clique no checkbox acione o handler do container
            ImageManager.toggleSelectImage(imageName, checkbox.checked, container);
        });
        checkboxWrapper.appendChild(checkbox);

        // Atualiza a classe 'selected' do container com base no estado do checkbox
        if (checkbox.checked) {
            container.classList.add('selected');
        } else {
            container.classList.remove('selected');
        }

        const img = document.createElement('img');
        const objectURL = Utils.createObjectURL(imageBlob); // Cria Object URL
        img.src = objectURL;
        img.dataset.objectUrl = objectURL; // Armazena o URL para revogação posterior
        img.alt = Utils.removeFileExtension(imageName);
        img.title = "Clique para ampliar";

        const nameSpan = document.createElement('span');
        nameSpan.className = 'image-name';
        nameSpan.textContent = Utils.removeFileExtension(imageName);
        nameSpan.title = "Clique para ampliar";

        // Botão de exclusão individual
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'ml-auto p-1 text-red-500 hover:text-red-700 rounded-full transition-colors hidden sm:block'; // Oculta em mobile pequeno, para focar no toque no container
        deleteBtn.innerHTML = '<i class="fas fa-times" aria-hidden="true"></i>';
        deleteBtn.setAttribute('aria-label', `Excluir cifra ${Utils.removeFileExtension(imageName)}`);
        deleteBtn.title = `Excluir ${Utils.removeFileExtension(imageName)}`;
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Impede que o clique se propague para o container
            ImageManager.deleteImage(imageName);
        });

        container.appendChild(checkboxWrapper); // Adiciona o checkbox
        container.appendChild(img);
        container.appendChild(nameSpan);
        container.appendChild(deleteBtn); // Adiciona o botão de exclusão

        return container;
      },

      updateSelectAllCheckbox: () => {
        const images = imageGalleryByTab.get(currentTab) || [];
        // Se não houver imagens, o "Selecionar todas" fica desabilitado
        if (images.length === 0) {
            DOM.selectAllCheckbox.checked = false;
            DOM.selectAllCheckbox.indeterminate = false;
            DOM.selectAllCheckbox.disabled = true;
            return;
        }

        DOM.selectAllCheckbox.disabled = false; // Habilita se houver imagens

        const selectedCount = selectedImagesByTab.get(currentTab).size;
        DOM.selectAllCheckbox.checked = selectedCount === images.length;
        DOM.selectAllCheckbox.indeterminate = selectedCount > 0 && selectedCount < images.length;
      },

      updateButtonsState: () => {
        const anySelected = selectedImagesByTab.get(currentTab).size > 0;
        DOM.deleteSelectedBtn.disabled = !anySelected;
        DOM.clearSelectionBtn.disabled = !anySelected;

        DOM.deleteSelectedBtn.setAttribute('aria-disabled', !anySelected);
        DOM.clearSelectionBtn.setAttribute('aria-disabled', !anySelected);
      },

      setSelectionMode: (active) => {
          isSelectingMode = active;
          if (active) {
              document.body.classList.add('selection-active');
          } else {
              document.body.classList.remove('selection-active');
              // Limpa todas as seleções se sair do modo de seleção sem nada selecionado
              if (selectedImagesByTab.get(currentTab).size === 0) {
                  ImageManager.clearSelection(); // Isso também vai esconder os checkboxes
              }
          }
          UI.updateSelectionControlsVisibility();
          UI.updateSelectAllCheckbox(); // Atualiza o estado do checkbox "Selecionar todas"
          UI.updateButtonsState(); // Atualiza o estado dos botões (habilitar/desabilitar)
      },

      updateSelectionControlsVisibility: () => {
        const anySelected = selectedImagesByTab.get(currentTab).size > 0;
        // Mostra os controles de seleção se estiver no modo de seleção OU se houver algo selecionado
        if (isSelectingMode || anySelected) {
            DOM.selectionControls.style.display = 'flex';
        } else {
            DOM.selectionControls.style.display = 'none';
        }
      },

      openFullscreen: (src, alt) => {
        // Se estiver no modo de seleção, não abre fullscreen
        if (isSelectingMode) return;

        const overlay = document.createElement('div');
        overlay.className = 'fullscreen-image';
        overlay.setAttribute('role', 'dialog');
        overlay.setAttribute('aria-modal', 'true');
        overlay.setAttribute('aria-label', `Visualização da imagem ${alt}`);

        const img = document.createElement('img');
        img.src = src;
        img.alt = alt;
        img.tabIndex = 0; // Torna a imagem focável
        img.style.transform = 'scale(1)';

        const controls = document.createElement('div');
        controls.className = 'fullscreen-controls';

        const zoomInBtn = document.createElement('button');
        zoomInBtn.className = 'zoom-btn';
        zoomInBtn.innerHTML = '<i class="fas fa-search-plus"></i>';
        zoomInBtn.setAttribute('aria-label', 'Zoom in');

        const zoomOutBtn = document.createElement('button');
        zoomOutBtn.className = 'zoom-btn';
        zoomOutBtn.innerHTML = '<i class="fas fa-search-minus"></i>';
        zoomOutBtn.setAttribute('aria-label', 'Zoom out');

        const resetZoomBtn = document.createElement('button');
        resetZoomBtn.className = 'zoom-btn';
        resetZoomBtn.innerHTML = '<i class="fas fa-expand"></i>';
        resetZoomBtn.setAttribute('aria-label', 'Reset zoom');

        let scale = 1;
        let translateX = 0, translateY = 0;
        let isDragging = false;
        let startPoint = { x: 0, y: 0 }; // Para mouse e touch

        const updateTransform = () => {
          img.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
        };

        zoomInBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          scale = Math.min(scale * 1.2, 5); // Limita o zoom máximo
          updateTransform();
        });

        zoomOutBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          scale = Math.max(scale / 1.2, 1); // Limita o zoom mínimo a 1
          if (scale === 1) { // Reseta a posição se o zoom for 1
            translateX = 0;
            translateY = 0;
          }
          updateTransform();
        });

        resetZoomBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          scale = 1;
          translateX = 0;
          translateY = 0;
          updateTransform();
        });

        // Eventos de mouse para zoom e arrastar
        img.addEventListener('wheel', (e) => {
          e.preventDefault();
          const delta = -e.deltaY;
          const oldScale = scale;
          if (delta > 0) {
            scale = Math.min(scale * 1.1, 5);
          } else {
            scale = Math.max(scale / 1.1, 1);
          }

          // Ajusta o translateX/Y para manter o ponto de zoom no centro da imagem
          const rect = img.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;

          translateX = translateX + mouseX * (1 / oldScale - 1 / scale);
          translateY = translateY + mouseY * (1 / oldScale - 1 / scale);
          
          if (scale === 1) { // Reseta a posição se o zoom for 1
            translateX = 0;
            translateY = 0;
          }
          updateTransform();
        });

        img.addEventListener('mousedown', (e) => {
          if (scale > 1) {
            isDragging = true;
            startPoint = { x: e.clientX - translateX, y: e.clientY - translateY };
            img.style.cursor = 'grabbing';
            overlay.style.cursor = 'grabbing';
          }
        });

        document.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          translateX = e.clientX - startPoint.x;
          translateY = e.clientY - startPoint.y;
          updateTransform();
        });

        document.addEventListener('mouseup', () => {
          isDragging = false;
          img.style.cursor = 'zoom-out';
          overlay.style.cursor = 'zoom-out';
        });

        // Eventos de toque para zoom e arrastar (Pan & Pinch-to-zoom)
        let initialPinchDistance = null;
        let lastScale = 1;

        img.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                startPoint = { x: e.touches[0].clientX - translateX, y: e.touches[0].clientY - translateY };
            } else if (e.touches.length === 2) {
                initialPinchDistance = Math.hypot(
                    e.touches[1].pageX - e.touches[0].pageX,
                    e.touches[1].pageY - e.touches[0].pageY
                );
                lastScale = scale; // Salva a escala atual antes do pinch
            }
            e.preventDefault(); // Impede o scroll da página
        }, { passive: false });

        img.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1 && isDragging) {
                translateX = e.touches[0].clientX - startPoint.x;
                translateY = e.touches[0].clientY - startPoint.y;
                updateTransform();
            } else if (e.touches.length === 2 && initialPinchDistance) {
                const currentPinchDistance = Math.hypot(
                    e.touches[1].pageX - e.touches[0].pageX,
                    e.touches[1].pageY - e.touches[0].pageY
                );
                scale = lastScale * (currentPinchDistance / initialPinchDistance);
                scale = Math.max(1, Math.min(scale, 5)); // Limita o zoom

                // Recalcula translateX/Y para "pinçar" no centro
                const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                const rect = img.getBoundingClientRect();
                const relativeX = centerX - rect.left;
                const relativeY = centerY - rect.top;

                translateX = translateX + relativeX * (1 / lastScale - 1 / scale);
                translateY = translateY + relativeY * (1 / lastScale - 1 / scale);

                if (scale === 1) { // Reseta a posição se o zoom for 1
                    translateX = 0;
                    translateY = 0;
                }
                updateTransform();
            }
            e.preventDefault();
        }, { passive: false });

        img.addEventListener('touchend', () => {
            isDragging = false;
            initialPinchDistance = null;
        });


        controls.appendChild(zoomInBtn);
        controls.appendChild(zoomOutBtn);
        controls.appendChild(resetZoomBtn);
        overlay.appendChild(img);
        overlay.appendChild(controls);
        document.body.appendChild(overlay);
        img.focus(); // Foca na imagem para permitir navegação por teclado

        const closeFullscreen = () => {
          document.body.removeChild(overlay);
          overlay.removeEventListener('click', closeFullscreen);
          document.removeEventListener('keydown', handleKeyDown);
          Utils.revokeObjectURL(img.src); // Libera o Object URL
        };

        const handleKeyDown = (e) => {
          if (e.key === 'Escape') closeFullscreen();
        };

        overlay.addEventListener('click', closeFullscreen); // Clique no overlay fecha
        img.addEventListener('click', (e) => e.stopPropagation()); // Impede que o clique na imagem feche o fullscreen
        document.addEventListener('keydown', handleKeyDown);
      }
    };

    // Gerenciamento de abas
    const TabManager = {
      switchTab: async tabName => {
        if (currentTab === tabName) return;
        currentTab = tabName;
        UI.updateTabsUI();
        UI.setSelectionMode(false); // Sai do modo de seleção ao trocar de aba
        await UI.renderImages();
        UI.updateButtonsState();
        StateManager.saveState();
      }
    };

    // Gerenciamento de imagens
    const ImageManager = {
      toggleSelectImage: (imageName, isChecked, container) => {
        const selectedSet = selectedImagesByTab.get(currentTab);

        if (isChecked) {
          selectedSet.add(imageName);
          container.classList.add('selected');
        } else {
          selectedSet.delete(imageName);
          container.classList.remove('selected');
        }

        UI.updateSelectAllCheckbox();
        UI.updateButtonsState();
        UI.updateSelectionControlsVisibility(); // Reavalia a visibilidade dos controles de seleção
        StateManager.saveState();
      },

      deleteImage: async imageName => {
        if (!confirm(`Tem certeza que deseja excluir "${Utils.removeFileExtension(imageName)}"?`)) return;

        UI.showLoading();
        try {
            await IndexedDBManager.deleteImageBlob(imageName);
            // Remove o nome da imagem do array da aba
            const images = imageGalleryByTab.get(currentTab).filter(name => name !== imageName);
            imageGalleryByTab.set(currentTab, images);
            selectedImagesByTab.get(currentTab).delete(imageName); // Garante que a imagem seja desmarcada se estiver selecionada

            await UI.renderImages(); // Re-renderiza a lista de imagens
            // Se nenhuma imagem estiver selecionada, pode sair do modo de seleção
            if (selectedImagesByTab.get(currentTab).size === 0) {
                UI.setSelectionMode(false); 
            }
            StateManager.saveState();
            Utils.showStatus('Imagem excluída com sucesso!');
        } catch (error) {
            console.error('Erro ao excluir imagem:', error);
            Utils.showStatus('Erro ao excluir imagem.');
        } finally {
            UI.hideLoading();
        }
      },

      reorderImages: async (fromIndex, toIndex) => {
        const images = imageGalleryByTab.get(currentTab) || [];
        const movedImageName = images.splice(fromIndex, 1)[0];
        images.splice(toIndex, 0, movedImageName);
        imageGalleryByTab.set(currentTab, images);

        await UI.renderImages(); // Re-renderiza para refletir a nova ordem
        StateManager.saveState();
      },

      deleteSelected: async () => {
        const selectedNames = Array.from(selectedImagesByTab.get(currentTab));
        const count = selectedNames.length;
        if (!count || !confirm(`Excluir ${count} imagem(ns) selecionada(s)?`)) return;

        UI.showLoading();
        try {
            for (const name of selectedNames) {
                await IndexedDBManager.deleteImageBlob(name);
            }

            const images = imageGalleryByTab.get(currentTab).filter(name =>
              !selectedImagesByTab.get(currentTab).has(name)
            );

            imageGalleryByTab.set(currentTab, images);
            selectedImagesByTab.get(currentTab).clear(); // Limpa a seleção após a exclusão

            await UI.renderImages();
            UI.setSelectionMode(false); // Sai do modo de seleção após excluir
            StateManager.saveState();
            Utils.showStatus(`${count} imagens excluídas.`);
        }
        catch (error) {
            console.error('Erro ao excluir imagens selecionadas:', error);
            Utils.showStatus('Erro ao excluir imagens.');
        } finally {
            UI.hideLoading();
        }
      },

      clearSelection: () => {
        selectedImagesByTab.get(currentTab).clear();
        UI.renderImages(); // Re-renderiza para remover a classe 'selected' e desmarcar checkboxes
        UI.setSelectionMode(false); // Sai do modo de seleção ao limpar tudo
        StateManager.saveState();
        Utils.showStatus('Seleção limpa.');
      },

      handleFileSelection: async (e) => {
        const files = Array.from(e.target.files); // Converte FileList para Array
        if (!files.length) return;

        UI.showLoading();

        if (!imageGalleryByTab.get(currentTab)) imageGalleryByTab.set(currentTab, []);
        if (!selectedImagesByTab.get(currentTab)) selectedImagesByTab.set(currentTab, new Set());

        const currentImageNamesInTab = new Set(imageGalleryByTab.get(currentTab));
        let loadedCount = 0;

        try {
          for (const file of files) {
            if (!file.type.startsWith('image/')) {
              console.warn(`Arquivo ignorado (não é imagem): ${file.name}`);
              continue;
            }

            try {
              const processed = await ImageProcessor.processImageFile(file);
              if (!processed) continue;

              await IndexedDBManager.addImageBlob(processed.name, processed.blob);

              if (!currentImageNamesInTab.has(processed.name)) {
                imageGalleryByTab.get(currentTab).push(processed.name);
                currentImageNamesInTab.add(processed.name);
              } else {
                console.warn(`Imagem "${processed.name}" já existe na aba atual. Conteúdo será atualizado.`);
              }
              loadedCount++;
            } catch (error) {
              console.error(`Erro ao processar ${file.name}:`, error);
              Utils.showStatus(`Erro ao carregar ${file.name}`);
            }
          }

          await UI.renderImages();
          StateManager.saveState();
          Utils.showStatus(`${loadedCount} imagem(ns) carregada(s) com sucesso!`);
        } catch (error) {
          console.error('Erro geral no carregamento:', error);
          Utils.showStatus('Erro ao carregar imagens.');
        } finally {
          UI.hideLoading();
        }
      }
    };

    // Configuração de eventos
    const EventManager = {
      setup: () => {
        // Eventos para "pressionar e segurar"
        DOM.imageList.addEventListener('mousedown', (e) => {
            const container = e.target.closest('.image-container');
            if (!container) return;

            // Inicia o timer para o "pressionar e segurar"
            longPressTimer = setTimeout(() => {
                UI.setSelectionMode(true); // Ativa o modo de seleção
                // Seleciona a imagem que foi "pressionada e segurada"
                const checkbox = container.querySelector('input[type="checkbox"]');
                if (checkbox && !checkbox.checked) {
                    checkbox.checked = true;
                    ImageManager.toggleSelectImage(container.dataset.name, true, container);
                }
            }, 500); // 500ms para considerar "pressionar e segurar"
        });

        DOM.imageList.addEventListener('mouseup', () => {
            clearTimeout(longPressTimer); // Cancela o timer se o botão for solto antes
        });

        DOM.imageList.addEventListener('mouseleave', () => {
            clearTimeout(longPressTimer); // Cancela o timer se o mouse sair do elemento
        });

        // Eventos de toque para "pressionar e segurar" (mobile)
        DOM.imageList.addEventListener('touchstart', (e) => {
            const container = e.target.closest('.image-container');
            if (!container) return;

            // Evita o zoom padrão ao tocar e segurar
            e.preventDefault(); 

            longPressTimer = setTimeout(() => {
                UI.setSelectionMode(true);
                const checkbox = container.querySelector('input[type="checkbox"]');
                if (checkbox && !checkbox.checked) {
                    checkbox.checked = true;
                    ImageManager.toggleSelectImage(container.dataset.name, true, container);
                }
            }, 500);
        }, { passive: false }); // Use passive: false para permitir preventDefault

        DOM.imageList.addEventListener('touchend', () => {
            clearTimeout(longPressTimer);
        });

        DOM.imageList.addEventListener('touchcancel', () => {
            clearTimeout(longPressTimer);
        });

        // Evento de clique no container (agora só abre fullscreen se não estiver em modo de seleção e for clicado na imagem/nome)
        DOM.imageList.addEventListener('click', async (e) => {
          const container = e.target.closest('.image-container');
          if (!container) return;

          // Se estiver no modo de seleção, um clique no container alterna a seleção
          if (isSelectingMode) {
            const checkbox = container.querySelector('input[type="checkbox"]');
            if (checkbox) {
                checkbox.checked = !checkbox.checked;
                ImageManager.toggleSelectImage(container.dataset.name, checkbox.checked, container);
            }
          } else {
            // Se não estiver no modo de seleção, verifica se o clique foi na imagem ou nome para abrir fullscreen
            if (e.target.tagName === 'IMG' || e.target.classList.contains('image-name')) {
                const imageName = container.dataset.name;
                const blob = await IndexedDBManager.getImageBlob(imageName);
                if (blob) {
                    const objectURL = Utils.createObjectURL(blob);
                    UI.openFullscreen(objectURL, Utils.removeFileExtension(imageName));
                } else {
                    Utils.showStatus('Erro: Imagem não encontrada para ampliar.');
                }
            }
          }
        });

        // Eventos de teclado para acessibilidade na lista de imagens
        DOM.imageList.addEventListener('keydown', (e) => {
          const container = e.target.closest('.image-container');
          if (!container) return;

          const imageName = container.dataset.name;

          if (e.key === ' ' || e.key === 'Enter') {
            e.preventDefault(); // Impede o scroll da página ao pressionar espaço
            if (isSelectingMode) {
                const checkbox = container.querySelector('input[type="checkbox"]');
                if (checkbox) {
                    checkbox.checked = !checkbox.checked;
                    ImageManager.toggleSelectImage(imageName, checkbox.checked, container);
                }
            } else {
                // Ativa o modo de seleção e seleciona a imagem se pressionar espaço/enter
                UI.setSelectionMode(true);
                const checkbox = container.querySelector('input[type="checkbox"]');
                if (checkbox && !checkbox.checked) {
                    checkbox.checked = true;
                    ImageManager.toggleSelectImage(imageName, true, container);
                }
            }
          }
          if (e.key === 'Delete' || e.key === 'Backspace') {
            e.preventDefault();
            if (isSelectingMode) {
                ImageManager.deleteImage(imageName);
            } else {
                // Se não estiver no modo de seleção, seleciona a imagem para exclusão
                UI.setSelectionMode(true);
                const checkbox = container.querySelector('input[type="checkbox"]');
                if (checkbox && !checkbox.checked) {
                    checkbox.checked = true;
                    ImageManager.toggleSelectImage(imageName, true, container);
                }
                Utils.showStatus('Pressione Excluir novamente para confirmar a exclusão da(s) imagem(ns) selecionada(s).');
            }
          }
        });

        // Eventos de Drag and Drop
        DOM.imageList.addEventListener('dragstart', (e) => {
          const container = e.target.closest('.image-container');
          if (!container) return;

          // Se estiver no modo de seleção, o drag é desativado para evitar conflito
          if (isSelectingMode) {
              e.preventDefault();
              return;
          }

          const currentImageNames = imageGalleryByTab.get(currentTab);
          dragStartIndex = currentImageNames.indexOf(container.dataset.name);

          container.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', container.dataset.name); // Dados para dragover
        });

        DOM.imageList.addEventListener('dragover', (e) => {
          e.preventDefault(); // Necessário para permitir o drop
          if (isSelectingMode) return; // Desativa dragover no modo de seleção

          const container = e.target.closest('.image-container');
          if (container && container.dataset.name !== e.dataTransfer.getData('text/plain')) { // Evita highlight no próprio elemento
            container.classList.add('drag-over');
          }
          e.dataTransfer.dropEffect = 'move';
        });

        DOM.imageList.addEventListener('dragleave', (e) => {
          if (isSelectingMode) return;
          const container = e.target.closest('.image-container');
          if (container) container.classList.remove('drag-over');
        });

        DOM.imageList.addEventListener('drop', (e) => {
          e.preventDefault();
          if (isSelectingMode) return; // Desativa drop no modo de seleção

          const container = e.target.closest('.image-container');
          if (container) {
            container.classList.remove('drag-over');
            const draggedImageName = e.dataTransfer.getData('text/plain');
            const dragEndIndex = imageGalleryByTab.get(currentTab).indexOf(container.dataset.name);
            
            if (dragStartIndex !== null && dragEndIndex !== -1 && dragStartIndex !== dragEndIndex) {
              ImageManager.reorderImages(dragStartIndex, dragEndIndex);
            }
          }
          dragStartIndex = null; // Reseta o índice de início
        });

        DOM.imageList.addEventListener('dragend', (e) => {
          const allImageContainers = DOM.imageList.querySelectorAll('.image-container');
          allImageContainers.forEach(container => {
            container.classList.remove('dragging', 'drag-over'); // Remove todas as classes de drag
          });
          dragStartIndex = null; // Garante que o índice é resetado, mesmo se o drop não ocorrer em um alvo válido
        });


        // Eventos dos botões de seleção
        DOM.selectAllCheckbox.addEventListener('change', () => {
          const images = imageGalleryByTab.get(currentTab) || [];
          const selectedSet = selectedImagesByTab.get(currentTab);
          const imageContainers = DOM.imageList.querySelectorAll('.image-container');

          if (DOM.selectAllCheckbox.checked) {
            images.forEach(name => selectedSet.add(name));
            imageContainers.forEach(container => {
                container.classList.add('selected');
                container.querySelector('input[type="checkbox"]').checked = true;
            });
          } else {
            selectedSet.clear();
            imageContainers.forEach(container => {
                container.classList.remove('selected');
                container.querySelector('input[type="checkbox"]').checked = false;
            });
          }

          UI.updateButtonsState();
          StateManager.saveState();
        });

        DOM.clearSelectionBtn.addEventListener('click', ImageManager.clearSelection);
        DOM.deleteSelectedBtn.addEventListener('click', ImageManager.deleteSelected);

        // Eventos dos botões de arquivo/nuvem
        DOM.openFileDialogButton.addEventListener('click', () => {
          DOM.fileInput.value = ''; // Limpa o valor do input para permitir selecionar o mesmo arquivo novamente
          DOM.fileInput.click();
        });
        DOM.fileInput.addEventListener('change', ImageManager.handleFileSelection);

        DOM.openCloudFolderButton.addEventListener('click', () => {
          window.open(ONE_DRIVE_FOLDER_URL, '_blank');
          Utils.showStatus('Abrindo pasta do OneDrive em uma nova aba.');
        });

        // Eventos dos botões do cabeçalho (apenas mensagens de status)
        DOM.syncBtn.addEventListener('click', () => {
          Utils.showStatus('Funcionalidade de Sincronização em desenvolvimento...');
        });

        DOM.settingsBtn.addEventListener('click', () => {
          Utils.showStatus('Funcionalidade de Configurações em desenvolvimento...');
        });
      }
    };

    // Função de inicialização
    async function init() {
      UI.showLoading();
      try {
        await IndexedDBManager.open(); // Abre a conexão com o IndexedDB
        await StateManager.loadState(); // Carrega o estado salvo
        UI.createTabs(); // Cria as abas dinamicamente
        UI.updateTabsUI(); // Atualiza o estado visual das abas
        await UI.renderImages(); // Renderiza as imagens da aba atual
        UI.setSelectionMode(false); // Inicia com o modo de seleção desativado
        EventManager.setup(); // Configura todos os ouvintes de eventos
      } catch (e) {
        console.error("Erro na inicialização:", e);
        Utils.showStatus("Erro ao iniciar o aplicativo. Tente recarregar a página.");
      } finally {
        UI.hideLoading(); // Esconde o spinner de carregamento
      }
    }

    document.addEventListener('DOMContentLoaded', init); // Inicia quando o DOM estiver pronto
  </script>
</body>
</html>
