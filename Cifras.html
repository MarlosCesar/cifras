<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Seletor de Cifras</title>
  
  <link rel="preload" href="https://cdn.tailwindcss.com" as="script">
  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --primary-color: #3b82f6;
      --primary-dark: #2563eb;
      --primary-hover: #e0e7ff;
      --danger-color: #ef4444;
      --danger-dark: #dc2626;
      --gray-light: #f3f4f6;
      --gray-medium: #e5e7eb;
      --text-color-dark: #333333;
      --text-color-light: #4b5563;
      --shadow-base: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-primary: 0 0 10px rgba(37, 99, 235, 0.3);
      --header-bg: #1A202C;
      --header-text: #E2E8F0;
      --header-hover: #2D3748;
    }

    html, body {
      overflow-x: hidden; 
      overflow-y: auto;
      background-color: var(--gray-light);
      font-family: 'Inter', sans-serif;
      color: var(--text-color-dark);
    }

    .header-professional {
      background-color: var(--header-bg);
      color: var(--header-text);
      box-shadow: var(--shadow-base);
    }

    .header-professional button {
      transition: background-color 0.3s ease, transform 0.1s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .header-professional button:hover {
      background-color: var(--header-hover);
    }

    .header-professional button:active {
      transform: scale(0.98);
    }

    .tabs {
      display: flex;
      gap: 0.5rem;
      border-bottom: 2px solid var(--gray-medium);
      margin-bottom: 1rem;
      flex-wrap: wrap;
      padding: 0 1rem;
    }

    .tab {
      padding: 0.65rem 1.2rem;
      cursor: pointer;
      border-radius: 0.5rem 0.5rem 0 0;
      background-color: #f9fafb;
      border: 1px solid transparent;
      border-bottom: 2px solid transparent;
      transition: all 0.2s ease;
      outline-offset: 2px;
      color: var(--text-color-light);
      font-weight: 500;
    }

    [role="tab"] {
      user-select: none;
    }

    .tab:hover,
    .tab:focus-visible {
      background-color: var(--primary-hover);
      border-color: var(--primary-color) transparent transparent;
      outline: none;
      color: var(--primary-dark);
    }

    .tab.active {
      background-color: white;
      border-color: var(--primary-color) var(--primary-color) white;
      font-weight: 600;
      color: var(--primary-dark);
      box-shadow: 0 -2px 5px rgba(0,0,0,0.05);
    }

    .image-container {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      border: 1px solid var(--gray-medium);
      border-radius: 0.75rem;
      overflow: hidden;
      cursor: pointer;
      transition: all 0.2s ease;
      background-color: white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    .image-container:focus-visible {
      outline: 2px solid var(--primary-color);
      outline-offset: 3px;
    }

    .image-container:hover {
      border-color: var(--primary-color);
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .image-container.selected {
      border-color: var(--primary-dark);
      box-shadow: var(--shadow-primary);
      background-color: var(--primary-hover);
    }

    .drag-over {
      border: 2px dashed var(--primary-dark) !important;
      background-color: rgba(59, 130, 246, 0.1) !important;
    }

    .image-container.dragging {
      opacity: 0.4;
      transform: scale(0.98);
    }

    .image-container img {
      width: 2.2cm;
      height: 3.3cm;
      object-fit: cover;
      border-radius: 0.35rem;
      flex-shrink: 0;
      box-shadow: 0 1px 4px rgba(0,0,0,0.1);
    }

    .image-name {
      font-size: 0.95rem;
      color: var(--text-color-dark);
      flex-grow: 1;
      overflow-wrap: break-word;
      word-break: break-word;
      max-width: calc(100% - 2.2cm - 12px);
      line-height: 1.4;
    }

    .fullscreen-image {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.95);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      touch-action: none;
    }

    .fullscreen-image img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      transition: transform 0.25s ease;
      transform-origin: center center;
    }

    .fullscreen-controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      background: rgba(0,0,0,0.7);
      padding: 12px 20px;
      border-radius: 8px;
    }

    .zoom-btn {
      background: rgba(255,255,255,0.2);
      color: white;
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.3s ease, transform 0.1s ease;
    }

    .zoom-btn:hover {
      background: rgba(255,255,255,0.3);
    }

    .zoom-btn:active {
      transform: scale(0.95);
    }

    .loading-spinner {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0,0,0,0.6);
      padding: 20px;
      border-radius: 12px;
      z-index: 10000;
      color: white;
    }

    .loading-spinner.active {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #status-message {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
      pointer-events: none;
      text-align: center;
    }

    #status-message.show {
      opacity: 1;
    }

    @media (max-width: 640px) {
      .header-professional h1 {
        font-size: 1.5rem;
      }
      .header-professional .space-x-4 {
        gap: 0.5rem;
      }
      .header-professional button {
        padding: 0.6rem;
      }

      .tabs {
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.35rem;
        padding: 0 0.5rem;
      }
      .tab {
        padding: 0.5rem 0.8rem;
        font-size: 0.9rem;
      }

      .main-content-area {
        padding: 0.75rem;
      }

      .image-container {
        flex-direction: row;
        align-items: center;
        gap: 10px;
        padding: 10px;
      }

      .image-container img {
        width: 1.8cm;
        height: 2.7cm;
      }

      .image-name {
        font-size: 0.875rem;
        max-width: calc(100% - 1.8cm - 10px);
      }

      .flex-wrap.gap-2 {
        flex-direction: column;
        width: 100%;
      }
      .flex-wrap.gap-2 button {
        width: 100%;
        justify-content: center;
      }
      .flex-wrap.gap-2 button i {
        margin-right: 0.5rem;
      }

      .fullscreen-controls {
        flex-direction: row;
        gap: 10px;
        padding: 10px 15px;
      }
      .zoom-btn {
        width: 45px;
        height: 45px;
        font-size: 22px;
      }
    }

    @media (min-width: 641px) and (max-width: 1024px) {
      .tabs {
        justify-content: flex-start;
        padding: 0 1.5rem;
      }
      .tab {
        padding: 0.6rem 1.1rem;
        font-size: 0.95rem;
      }
      .image-container {
        padding: 10px;
        gap: 10px;
      }
      .image-container img {
        width: 2cm;
        height: 3cm;
      }
      .image-name {
        font-size: 0.9rem;
        max-width: calc(100% - 2cm - 10px);
      }
    }
  </style>
</head>
<body class="bg-gray-100 font-sans antialiased">
  <header class="header-professional p-4">
    <div class="container mx-auto flex justify-between items-center">
      <h1 class="text-2xl font-semibold tracking-wide">Seletor de Cifras</h1>
      <div class="flex items-center space-x-4">
        <button id="sync-btn" class="p-2 rounded-full" aria-label="Sincronizar" title="Sincronizar">
          <i class="fas fa-sync-alt text-lg" aria-hidden="true"></i>
        </button>
        <button id="settings-btn" class="p-2 rounded-full" aria-label="Configurações" title="Configurações">
          <i class="fas fa-cog text-lg" aria-hidden="true"></i>
        </button>
      </div>
    </div>
  </header>

  <main class="container mx-auto p-4 flex flex-col gap-4 main-content-area" role="main">
    <section class="w-full bg-white rounded-xl shadow-md overflow-hidden flex flex-col" aria-label="Seletor de músicas e imagens">
      <div class="p-4 bg-gray-50 border-b flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
        <h2 class="font-semibold text-xl text-gray-700">Minhas Cifras</h2>
        <div class="flex flex-wrap gap-2 justify-end">
          <button id="open-cloud-folder" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition flex items-center" aria-label="Buscar cifras na nuvem (OneDrive)" title="Buscar cifras na nuvem (OneDrive)">
            <i class="fas fa-cloud mr-2" aria-hidden="true"></i> Buscar em Nuvem
          </button>
          <button id="open-file-dialog" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition flex items-center" aria-label="Buscar cifras localmente" title="Buscar cifras localmente">
            <i class="fas fa-folder-open mr-2" aria-hidden="true"></i> Buscar Local
          </button>
          <input type="file" id="file-input" class="hidden" accept="image/*" multiple aria-hidden="true" tabindex="-1" />
        </div>
      </div>

      <nav class="tabs" id="tabs-container" role="tablist" aria-label="Abas das categorias de cifras">
      </nav>

      <div class="p-4 flex flex-col gap-4 flex-1">
        <div class="flex flex-wrap items-center gap-4 mb-2">
          <label class="inline-flex items-center gap-2 cursor-pointer text-gray-700 font-medium" for="select-all">
            <input type="checkbox" id="select-all" class="form-checkbox h-5 w-5 text-blue-600 rounded focus:ring-blue-500" aria-label="Selecionar todas as imagens" />
            <span>Selecionar todas</span>
          </label>
          <button id="clear-selection-btn" class="bg-gray-400 text-white px-4 py-2 rounded-lg hover:bg-gray-500 transition disabled:opacity-50 disabled:cursor-not-allowed flex items-center" disabled aria-disabled="true" aria-label="Limpar seleção">
            <i class="fas fa-undo mr-2" aria-hidden="true"></i> Limpar seleção
          </button>
          <button id="delete-selected-btn" class="bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 transition disabled:opacity-50 disabled:cursor-not-allowed flex items-center" disabled aria-disabled="true" aria-label="Excluir imagens selecionadas">
            <i class="fas fa-trash-alt mr-2" aria-hidden="true"></i> Excluir selecionadas
          </button>
        </div>

        <div id="image-list" class="flex flex-col gap-4" aria-live="polite" aria-atomic="true">
          <p class="text-center text-gray-500 py-8">Nenhuma imagem encontrada nesta categoria.</p>
        </div>
      </div>
    </section>
  </main>

  <div id="loading-spinner" class="loading-spinner">
    <i class="fas fa-spinner fa-spin fa-3x text-blue-600" aria-hidden="true"></i>
    <span class="sr-only">Carregando...</span>
  </div>

  <div id="status-message" aria-live="polite"></div>

  <script>
    // Cache de elementos DOM
    const DOM = {
      tabsContainer: document.getElementById('tabs-container'),
      imageList: document.getElementById('image-list'),
      fileInput: document.getElementById('file-input'),
      openFileDialogButton: document.getElementById('open-file-dialog'),
      openCloudFolderButton: document.getElementById('open-cloud-folder'),
      selectAllCheckbox: document.getElementById('select-all'),
      deleteSelectedBtn: document.getElementById('delete-selected-btn'),
      clearSelectionBtn: document.getElementById('clear-selection-btn'),
      syncBtn: document.getElementById('sync-btn'),
      settingsBtn: document.getElementById('settings-btn'),
      loadingSpinner: document.getElementById('loading-spinner'),
      statusMessage: document.getElementById('status-message')
    };

    // Abas desejadas
    const tabs = ["Domingo Manhã", "Domingo Noite", "Segunda", "Quarta", "Culto Jovem", "Santa Ceia", "Outros"];

    // URL da pasta do OneDrive
    const ONE_DRIVE_FOLDER_URL = "https://1drv.ms/f/c/a71268bf66931c02/EpYyUsypAQhGgpWC9YuvE54BD_o9NX9tRar0piSzq4V4Xg";

    // Estado otimizado com Map/Set
    let imageGalleryByTab = new Map();
    let selectedImagesByTab = new Map();
    let currentTab = tabs[0];
    let dragStartIndex = null;

    // Inicializar estado
    tabs.forEach(tab => {
      imageGalleryByTab.set(tab, []);
      selectedImagesByTab.set(tab, new Set());
    });

    // Funções utilitárias
    const Utils = {
      removeFileExtension: filename => filename.replace(/\.[^/.]+$/, ""),
      showStatus: message => {
        DOM.statusMessage.textContent = message;
        DOM.statusMessage.classList.add('show');
        setTimeout(() => DOM.statusMessage.classList.remove('show'), 3000);
      },
      debounce: (func, timeout = 100) => {
        let timer;
        return (...args) => {
          clearTimeout(timer);
          timer = setTimeout(() => { func.apply(this, args); }, timeout);
        };
      },
      objectURLCache: new Map(),
      revokeObjectURL: (url) => {
          if (Utils.objectURLCache.has(url)) {
              URL.revokeObjectURL(url);
              Utils.objectURLCache.delete(url);
          }
      },
      createObjectURL: (blob) => {
          const url = URL.createObjectURL(blob);
          Utils.objectURLCache.set(url, true);
          return url;
      }
    };

    // --- IndexedDB Manager ---
    const DB_NAME = 'ImageSelectorDB';
    const DB_VERSION = 2;
    const STORE_IMAGES = 'images';
    const STORE_METADATA = 'metadata';

    const IndexedDBManager = {
      db: null,

      open: () => new Promise((resolve, reject) => {
        if (IndexedDBManager.db) {
            resolve(IndexedDBManager.db);
            return;
        }

        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_IMAGES)) {
            db.createObjectStore(STORE_IMAGES, { keyPath: 'name' });
          }
          if (!db.objectStoreNames.contains(STORE_METADATA)) {
            db.createObjectStore(STORE_METADATA, { keyPath: 'id' });
          }
        };

        request.onsuccess = (event) => {
          IndexedDBManager.db = event.target.result;
          resolve(IndexedDBManager.db);
        };

        request.onerror = (event) => {
          console.error('IndexedDB error:', event.target.errorCode);
          reject(event.target.errorCode);
        };
      }),

      addImageBlob: (imageName, blob) => new Promise(async (resolve, reject) => {
        try {
          const db = await IndexedDBManager.open();
          const transaction = db.transaction([STORE_IMAGES], 'readwrite');
          const store = transaction.objectStore(STORE_IMAGES);
          const request = store.put({ name: imageName, blob: blob });

          request.onsuccess = () => resolve();
          request.onerror = (event) => reject(event.target.error);
        } catch (e) {
          reject(e);
        }
      }),

      getImageBlob: (imageName) => new Promise(async (resolve, reject) => {
        try {
          const db = await IndexedDBManager.open();
          const transaction = db.transaction([STORE_IMAGES], 'readonly');
          const store = transaction.objectStore(STORE_IMAGES);
          const request = store.get(imageName);

          request.onsuccess = (event) => resolve(event.target.result ? event.target.result.blob : null);
          request.onerror = (event) => reject(event.target.error);
        } catch (e) {
          reject(e);
        }
      }),

      deleteImageBlob: (imageName) => new Promise(async (resolve, reject) => {
        try {
          const db = await IndexedDBManager.open();
          const transaction = db.transaction([STORE_IMAGES], 'readwrite');
          const store = transaction.objectStore(STORE_IMAGES);
          const request = store.delete(imageName);

          request.onsuccess = () => resolve();
          request.onerror = (event) => reject(event.target.error);
        } catch (e) {
          reject(e);
        }
      }),

      getAllImageNames: () => new Promise(async (resolve, reject) => {
          try {
              const db = await IndexedDBManager.open();
              const transaction = db.transaction([STORE_IMAGES], 'readonly');
              const store = transaction.objectStore(STORE_IMAGES);
              const request = store.getAllKeys();

              request.onsuccess = (event) => resolve(event.target.result);
              request.onerror = (event) => reject(event.target.error);
          } catch (e) {
              reject(e);
          }
      }),

      saveMetadata: (state) => new Promise(async (resolve, reject) => {
        try {
          const db = await IndexedDBManager.open();
          const transaction = db.transaction([STORE_METADATA], 'readwrite');
          const store = transaction.objectStore(STORE_METADATA);
          const request = store.put({ id: 'appState', state: state });

          request.onsuccess = () => resolve();
          request.onerror = (event) => reject(event.target.error);
        } catch (e) {
          reject(e);
        }
      }),

      loadMetadata: () => new Promise(async (resolve, reject) => {
        try {
          const db = await IndexedDBManager.open();
          const transaction = db.transaction([STORE_METADATA], 'readonly');
          const store = transaction.objectStore(STORE_METADATA);
          const request = store.get('appState');

          request.onsuccess = (event) => resolve(event.target.result ? event.target.result.state : null);
          request.onerror = (event) => reject(event.target.error);
        } catch (e) {
          reject(e);
        }
      })
    };

    // Processamento de imagens
    const ImageProcessor = {
      processImageFile: file => new Promise((resolve, reject) => {
        const img = new Image();
        const url = Utils.createObjectURL(file);

        img.onload = () => {
          const canvas = document.createElement('canvas');
          const MAX_SIZE = 800;
          let width = img.width;
          let height = img.height;

          if (width > height) {
            if (width > MAX_SIZE) {
              height *= MAX_SIZE / width;
              width = MAX_SIZE;
            }
          } else {
            if (height > MAX_SIZE) {
              width *= MAX_SIZE / height;
              height = MAX_SIZE;
            }
          }

          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, width, height);

          canvas.toBlob(blob => {
            Utils.revokeObjectURL(url);
            if (blob) {
                resolve({
                    name: file.name,
                    blob: blob
                });
            } else {
                reject(new Error('Falha ao criar Blob da imagem.'));
            }
          }, 'image/webp', 0.75);
        };

        img.onerror = () => {
          Utils.revokeObjectURL(url);
          reject(new Error('Erro ao carregar a imagem para processamento.'));
        };

        img.src = url;
      })
    };

    // Gerenciamento de estado
    const StateManager = {
        saveState: Utils.debounce(async () => {
            const state = {
                images: Object.fromEntries(Array.from(imageGalleryByTab.entries()).map(([tab, names]) => [tab, Array.from(names)])),
                selected: Object.fromEntries(Array.from(selectedImagesByTab.entries()).map(([tab, set]) => [tab, Array.from(set)])),
                currentTab,
            };
            try {
                await IndexedDBManager.saveMetadata(state);
            } catch (e) {
                console.error('Erro ao salvar estado no IndexedDB:', e);
                Utils.showStatus('Erro ao salvar dados.');
            }
        }, 500),

        loadState: async () => {
            try {
                const state = await IndexedDBManager.loadMetadata();
                if (state) {
                    imageGalleryByTab = new Map(Object.entries(state.images || {}));
                    selectedImagesByTab = new Map();
                    for (const tab of tabs) {
                        selectedImagesByTab.set(tab, new Set(state.selected?.[tab] || []));
                    }
                    currentTab = state.currentTab || tabs[0];
                } else {
                    StateManager.initEmptyState();
                }
            } catch (e) {
                console.error('Erro ao carregar estado do IndexedDB:', e);
                StateManager.initEmptyState();
            }
        },

        initEmptyState: () => {
            imageGalleryByTab = new Map();
            selectedImagesByTab = new Map();
            tabs.forEach(tab => {
                imageGalleryByTab.set(tab, []);
                selectedImagesByTab.set(tab, new Set());
            });
        }
    };

    // Interface do usuário
    const UI = {
      showLoading: () => DOM.loadingSpinner.classList.add('active'),
      hideLoading: () => DOM.loadingSpinner.classList.remove('active'),

      createTabs: () => {
        DOM.tabsContainer.innerHTML = '';
        const fragment = document.createDocumentFragment();

        tabs.forEach((tab, index) => {
          const tabBtn = document.createElement('button');
          tabBtn.className = 'tab';
          tabBtn.setAttribute('role', 'tab');
          tabBtn.setAttribute('tabindex', index === 0 ? '0' : '-1');
          tabBtn.setAttribute('aria-selected', index === 0 ? 'true' : 'false');
          tabBtn.id = `tab-${tab.replace(/\s+/g, '-').toLowerCase()}`;
          tabBtn.textContent = tab;

          tabBtn.addEventListener('click', () => TabManager.switchTab(tab));
          tabBtn.addEventListener('keydown', (e) => {
            const currentActiveIndex = tabs.indexOf(currentTab);
            let nextIndex = currentActiveIndex;

            if (e.key === 'ArrowRight') {
              nextIndex = (currentActiveIndex + 1) % tabs.length;
            } else if (e.key === 'ArrowLeft') {
              nextIndex = (currentActiveIndex - 1 + tabs.length) % tabs.length;
            } else if (e.key === 'Home') {
              nextIndex = 0;
            } else if (e.key === 'End') {
              nextIndex = tabs.length - 1;
            }

            if (nextIndex !== currentActiveIndex) {
              e.preventDefault();
              TabManager.switchTab(tabs[nextIndex]);
              DOM.tabsContainer.querySelector(`#tab-${tabs[nextIndex].replace(/\s+/g, '-').toLowerCase()}`).focus();
            } else if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              TabManager.switchTab(tab);
            }
          });

          fragment.appendChild(tabBtn);
        });

        DOM.tabsContainer.appendChild(fragment);
      },

      updateTabsUI: () => {
        const buttons = DOM.tabsContainer.querySelectorAll('.tab');
        buttons.forEach(btn => {
          const isActive = btn.textContent === currentTab;
          btn.classList.toggle('active', isActive);
          btn.setAttribute('aria-selected', isActive);
          btn.setAttribute('tabindex', isActive ? '0' : '-1');
        });
      },

      renderImages: async () => {
        DOM.imageList.querySelectorAll('img[data-object-url]').forEach(img => {
            Utils.revokeObjectURL(img.dataset.objectUrl);
        });

        const imageNames = imageGalleryByTab.get(currentTab) || [];
        const fragment = document.createDocumentFragment();

        if (imageNames.length === 0) {
          const p = document.createElement('p');
          p.className = 'text-center text-gray-500 py-8';
          p.textContent = 'Nenhuma imagem encontrada nesta categoria.';
          fragment.appendChild(p);
          DOM.selectAllCheckbox.checked = false;
          DOM.selectAllCheckbox.disabled = true;
        } else {
          DOM.selectAllCheckbox.disabled = false;

          const imagesToRender = [];
          for (const imageName of imageNames) {
            const blob = await IndexedDBManager.getImageBlob(imageName);
            if (blob) {
                imagesToRender.push({ name: imageName, blob: blob });
            } else {
                console.warn(`Imagem ${imageName} não encontrada no IndexedDB. Removendo da lista.`);
                imageGalleryByTab.set(currentTab, imageNames.filter(name => name !== imageName));
                selectedImagesByTab.get(currentTab).delete(imageName);
            }
          }

          imagesToRender.forEach(({ name, blob }) => {
            const container = UI.createImageElement(name, blob);
            fragment.appendChild(container);
          });
        }

        DOM.imageList.innerHTML = '';
        DOM.imageList.appendChild(fragment);
        UI.updateSelectAllCheckbox();
        UI.updateButtonsState();
      },

      createImageElement: (imageName, imageBlob) => {
        const container = document.createElement('div');
        container.className = 'image-container';
        container.setAttribute('draggable', 'true');
        container.setAttribute('tabindex', '0');
        container.setAttribute('role', 'checkbox');
        container.setAttribute('aria-checked', selectedImagesByTab.get(currentTab).has(imageName));
        container.dataset.name = imageName;

        if (selectedImagesByTab.get(currentTab).has(imageName)) {
          container.classList.add('selected');
        }

        const img = document.createElement('img');
        const objectURL = Utils.createObjectURL(imageBlob);
        img.src = objectURL;
        img.dataset.objectUrl = objectURL;
        img.alt = Utils.removeFileExtension(imageName);
        img.title = "Clique para ampliar";

        const nameSpan = document.createElement('span');
        nameSpan.className = 'image-name';
        nameSpan.textContent = Utils.removeFileExtension(imageName);
        nameSpan.title = "Clique para ampliar";

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'ml-auto p-1 text-red-500 hover:text-red-700 rounded-full transition-colors hidden sm:block';
        deleteBtn.innerHTML = '<i class="fas fa-times" aria-hidden="true"></i>';
        deleteBtn.setAttribute('aria-label', `Excluir cifra ${Utils.removeFileExtension(imageName)}`);
        deleteBtn.title = `Excluir ${Utils.removeFileExtension(imageName)}`;
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            ImageManager.deleteImage(imageName);
        });

        container.appendChild(img);
        container.appendChild(nameSpan);
        container.appendChild(deleteBtn);

        // Variáveis para controle de long press
        let pressTimer;
        let isLongPress = false;
        let touchStartX = 0;
        let touchStartY = 0;

        // Evento de toque iniciado
        container.addEventListener('touchstart', (e) => {
            isLongPress = false;
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            
            pressTimer = setTimeout(() => {
                isLongPress = true;
                ImageManager.toggleSelectImage(imageName, container);
            }, 500); // 500ms para considerar como long press
        }, { passive: true });

        // Evento de toque movido
        container.addEventListener('touchmove', (e) => {
            // Se o movimento for significativo, cancela o long press
            const moveX = Math.abs(e.touches[0].clientX - touchStartX);
            const moveY = Math.abs(e.touches[0].clientY - touchStartY);
            
            if (moveX > 10 || moveY > 10) {
                clearTimeout(pressTimer);
            }
        }, { passive: true });

        // Evento de toque finalizado
        container.addEventListener('touchend', (e) => {
            clearTimeout(pressTimer);
            
            // Se não foi um long press e o toque foi rápido (tap), abre em fullscreen
            if (!isLongPress && e.changedTouches.length === 1) {
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                
                // Verifica se o toque terminou próximo ao início (não foi um arrasto)
                if (Math.abs(touchEndX - touchStartX) < 10 && Math.abs(touchEndY - touchStartY) < 10) {
                    const objectURL = Utils.createObjectURL(imageBlob);
                    UI.openFullscreen(objectURL, Utils.removeFileExtension(imageName));
                }
            }
        }, { passive: true });

        // Eventos de mouse para desktop
        container.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return; // Apenas botão esquerdo
            pressTimer = setTimeout(() => {
                isLongPress = true;
                ImageManager.toggleSelectImage(imageName, container);
            }, 500);
        });

        container.addEventListener('mousemove', (e) => {
            clearTimeout(pressTimer);
        });

        container.addEventListener('mouseup', (e) => {
            clearTimeout(pressTimer);
            if (!isLongPress && e.button === 0) {
                const objectURL = Utils.createObjectURL(imageBlob);
                UI.openFullscreen(objectURL, Utils.removeFileExtension(imageName));
            }
            isLongPress = false;
        });

        container.addEventListener('mouseleave', () => {
            clearTimeout(pressTimer);
            isLongPress = false;
        });

        // Eventos de drag and drop
        container.addEventListener('dragstart', (e) => {
            if (!selectedImagesByTab.get(currentTab).has(imageName)) {
                ImageManager.toggleSelectImage(imageName, container);
            }
            container.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', imageName);
        });

        return container;
      },

      updateSelectAllCheckbox: () => {
        const images = imageGalleryByTab.get(currentTab) || [];
        if (images.length === 0) {
          DOM.selectAllCheckbox.checked = false;
          DOM.selectAllCheckbox.indeterminate = false;
          DOM.selectAllCheckbox.disabled = true;
          return;
        }

        DOM.selectAllCheckbox.disabled = false;
        const selectedCount = selectedImagesByTab.get(currentTab).size;
        DOM.selectAllCheckbox.checked = selectedCount === images.length;
        DOM.selectAllCheckbox.indeterminate = selectedCount > 0 && selectedCount < images.length;
      },

      updateButtonsState: () => {
        const anySelected = selectedImagesByTab.get(currentTab).size > 0;
        DOM.deleteSelectedBtn.disabled = !anySelected;
        DOM.clearSelectionBtn.disabled = !anySelected;

        DOM.deleteSelectedBtn.setAttribute('aria-disabled', !anySelected);
        DOM.clearSelectionBtn.setAttribute('aria-disabled', !anySelected);
      },

      openFullscreen: (src, alt) => {
        const overlay = document.createElement('div');
        overlay.className = 'fullscreen-image';
        overlay.setAttribute('role', 'dialog');
        overlay.setAttribute('aria-modal', 'true');
        overlay.setAttribute('aria-label', `Visualização da imagem ${alt}`);

        const img = document.createElement('img');
        img.src = src;
        img.alt = alt;
        img.tabIndex = 0;
        img.style.transform = 'scale(1)';

        const controls = document.createElement('div');
        controls.className = 'fullscreen-controls';

        const zoomInBtn = document.createElement('button');
        zoomInBtn.className = 'zoom-btn';
        zoomInBtn.innerHTML = '<i class="fas fa-search-plus"></i>';
        zoomInBtn.setAttribute('aria-label', 'Zoom in');

        const zoomOutBtn = document.createElement('button');
        zoomOutBtn.className = 'zoom-btn';
        zoomOutBtn.innerHTML = '<i class="fas fa-search-minus"></i>';
        zoomOutBtn.setAttribute('aria-label', 'Zoom out');

        const resetZoomBtn = document.createElement('button');
        resetZoomBtn.className = 'zoom-btn';
        resetZoomBtn.innerHTML = '<i class="fas fa-expand"></i>';
        resetZoomBtn.setAttribute('aria-label', 'Reset zoom');

        let scale = 1;
        let translateX = 0, translateY = 0;
        let isDragging = false;
        let startPoint = { x: 0, y: 0 };
        let initialPinchDistance = null;
        let lastScale = 1;

        const updateTransform = () => {
          img.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
        };

        zoomInBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          scale = Math.min(scale * 1.2, 5);
          updateTransform();
        });

        zoomOutBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          scale = Math.max(scale / 1.2, 1);
          if (scale === 1) {
            translateX = 0;
            translateY = 0;
          }
          updateTransform();
        });

        resetZoomBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          scale = 1;
          translateX = 0;
          translateY = 0;
          updateTransform();
        });

        // Eventos de mouse
        img.addEventListener('wheel', (e) => {
          e.preventDefault();
          const delta = -e.deltaY;
          const oldScale = scale;
          if (delta > 0) {
            scale = Math.min(scale * 1.1, 5);
          } else {
            scale = Math.max(scale / 1.1, 1);
          }

          const rect = img.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;

          translateX = translateX + mouseX * (1 / oldScale - 1 / scale);
          translateY = translateY + mouseY * (1 / oldScale - 1 / scale);
          
          if (scale === 1) {
            translateX = 0;
            translateY = 0;
          }
          updateTransform();
        });

        img.addEventListener('mousedown', (e) => {
          if (scale > 1) {
            isDragging = true;
            startPoint = { x: e.clientX - translateX, y: e.clientY - translateY };
            img.style.cursor = 'grabbing';
            overlay.style.cursor = 'grabbing';
          }
        });

        document.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          translateX = e.clientX - startPoint.x;
          translateY = e.clientY - startPoint.y;
          updateTransform();
        });

        document.addEventListener('mouseup', () => {
          isDragging = false;
          img.style.cursor = 'zoom-out';
          overlay.style.cursor = 'zoom-out';
        });

        // Eventos de toque
        img.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                startPoint = { x: e.touches[0].clientX - translateX, y: e.touches[0].clientY - translateY };
            } else if (e.touches.length === 2) {
                initialPinchDistance = Math.hypot(
                    e.touches[1].pageX - e.touches[0].pageX,
                    e.touches[1].pageY - e.touches[0].pageY
                );
                lastScale = scale;
            }
            e.preventDefault();
        }, { passive: false });

        img.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1 && isDragging) {
                translateX = e.touches[0].clientX - startPoint.x;
                translateY = e.touches[0].clientY - startPoint.y;
                updateTransform();
            } else if (e.touches.length === 2 && initialPinchDistance) {
                const currentPinchDistance = Math.hypot(
                    e.touches[1].pageX - e.touches[0].pageX,
                    e.touches[1].pageY - e.touches[0].pageY
                );
                scale = lastScale * (currentPinchDistance / initialPinchDistance);
                scale = Math.max(1, Math.min(scale, 5));

                const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                const rect = img.getBoundingClientRect();
                const relativeX = centerX - rect.left;
                const relativeY = centerY - rect.top;

                translateX = translateX + relativeX * (1 / lastScale - 1 / scale);
                translateY = translateY + relativeY * (1 / lastScale - 1 / scale);

                if (scale === 1) {
                    translateX = 0;
                    translateY = 0;
                }
                updateTransform();
            }
            e.preventDefault();
        }, { passive: false });

        img.addEventListener('touchend', () => {
            isDragging = false;
            initialPinchDistance = null;
        });

        controls.appendChild(zoomInBtn);
        controls.appendChild(zoomOutBtn);
        controls.appendChild(resetZoomBtn);
        overlay.appendChild(img);
        overlay.appendChild(controls);
        document.body.appendChild(overlay);
        img.focus();

        const closeFullscreen = () => {
          document.body.removeChild(overlay);
          overlay.removeEventListener('click', closeFullscreen);
          document.removeEventListener('keydown', handleKeyDown);
          Utils.revokeObjectURL(img.src);
        };

        const handleKeyDown = (e) => {
          if (e.key === 'Escape') closeFullscreen();
        };

        overlay.addEventListener('click', closeFullscreen);
        img.addEventListener('click', (e) => e.stopPropagation());
        document.addEventListener('keydown', handleKeyDown);
      }
    };

    // Gerenciamento de abas
    const TabManager = {
      switchTab: async tabName => {
        if (currentTab === tabName) return;
        currentTab = tabName;
        UI.updateTabsUI();
        await UI.renderImages();
        UI.updateButtonsState();
        StateManager.saveState();
      }
    };

    // Gerenciamento de imagens
    const ImageManager = {
      toggleSelectImage: (imageName, container) => {
        const selectedSet = selectedImagesByTab.get(currentTab);

        if (selectedSet.has(imageName)) {
          selectedSet.delete(imageName);
          container.classList.remove('selected');
          container.setAttribute('aria-checked', 'false');
        } else {
          selectedSet.add(imageName);
          container.classList.add('selected');
          container.setAttribute('aria-checked', 'true');
        }

        UI.updateSelectAllCheckbox();
        UI.updateButtonsState();
        StateManager.saveState();
      },

      deleteImage: async imageName => {
        if (!confirm(`Tem certeza que deseja excluir "${Utils.removeFileExtension(imageName)}"?`)) return;

        UI.showLoading();
        try {
            await IndexedDBManager.deleteImageBlob(imageName);
            const images = imageGalleryByTab.get(currentTab).filter(name => name !== imageName);
            imageGalleryByTab.set(currentTab, images);
            selectedImagesByTab.get(currentTab).delete(imageName);

            await UI.renderImages();
            StateManager.saveState();
            Utils.showStatus('Imagem excluída com sucesso!');
        } catch (error) {
            console.error('Erro ao excluir imagem:', error);
            Utils.showStatus('Erro ao excluir imagem.');
        } finally {
            UI.hideLoading();
        }
      },

      reorderImages: async (fromIndex, toIndex) => {
        const images = imageGalleryByTab.get(currentTab) || [];
        const movedImageName = images.splice(fromIndex, 1)[0];
        images.splice(toIndex, 0, movedImageName);
        imageGalleryByTab.set(currentTab, images);

        await UI.renderImages();
        StateManager.saveState();
      },

      deleteSelected: async () => {
        const selectedNames = Array.from(selectedImagesByTab.get(currentTab));
        const count = selectedNames.length;
        if (!count || !confirm(`Excluir ${count} imagem(ns) selecionada(s)?`)) return;

        UI.showLoading();
        try {
            for (const name of selectedNames) {
                await IndexedDBManager.deleteImageBlob(name);
            }

            const images = imageGalleryByTab.get(currentTab).filter(name =>
              !selectedImagesByTab.get(currentTab).has(name)
            );

            imageGalleryByTab.set(currentTab, images);
            selectedImagesByTab.get(currentTab).clear();

            await UI.renderImages();
            UI.updateButtonsState();
            StateManager.saveState();
            Utils.showStatus(`${count} imagens excluídas.`);
        }
        catch (error) {
            console.error('Erro ao excluir imagens selecionadas:', error);
            Utils.showStatus('Erro ao excluir imagens.');
        } finally {
            UI.hideLoading();
        }
      },

      clearSelection: () => {
        selectedImagesByTab.get(currentTab).clear();
        UI.renderImages();
        UI.updateButtonsState();
        StateManager.saveState();
        Utils.showStatus('Seleção limpa.');
      },

      handleFileSelection: async (e) => {
        const files = Array.from(e.target.files);
        if (!files.length) return;

        UI.showLoading();

        if (!imageGalleryByTab.get(currentTab)) imageGalleryByTab.set(currentTab, []);
        if (!selectedImagesByTab.get(currentTab)) selectedImagesByTab.set(currentTab, new Set());

        const currentImageNamesInTab = new Set(imageGalleryByTab.get(currentTab));
        let loadedCount = 0;

        try {
          for (const file of files) {
            if (!file.type.startsWith('image/')) {
              console.warn(`Arquivo ignorado (não é imagem): ${file.name}`);
              continue;
            }

            try {
              const processed = await ImageProcessor.processImageFile(file);
              if (!processed) continue;

              await IndexedDBManager.addImageBlob(processed.name, processed.blob);

              if (!currentImageNamesInTab.has(processed.name)) {
                imageGalleryByTab.get(currentTab).push(processed.name);
                currentImageNamesInTab.add(processed.name);
              } else {
                console.warn(`Imagem "${processed.name}" já existe na aba atual. Conteúdo será atualizado.`);
              }
              loadedCount++;
            } catch (error) {
              console.error(`Erro ao processar ${file.name}:`, error);
              Utils.showStatus(`Erro ao carregar ${file.name}`);
            }
          }

          await UI.renderImages();
          StateManager.saveState();
          Utils.showStatus(`${loadedCount} imagem(ns) carregada(s) com sucesso!`);
        } catch (error) {
          console.error('Erro geral no carregamento:', error);
          Utils.showStatus('Erro ao carregar imagens.');
        } finally {
          UI.hideLoading();
        }
      }
    };

    // Configuração de eventos
    const EventManager = {
    setup: () => {
      // Drag & Drop REORDENAR
      let draggedElement = null;

      DOM.imageList.addEventListener('dragstart', (e) => {
        const container = e.target.closest('.image-container');
        if (!container) return;
        draggedElement = container;
        dragStartIndex = Array.from(DOM.imageList.children).indexOf(container);
        container.classList.add('dragging');
      });

      DOM.imageList.addEventListener('dragover', (e) => {
        e.preventDefault();
        const afterElement = getDragAfterElement(DOM.imageList, e.clientY);
        DOM.imageList.querySelectorAll('.image-container').forEach(el => el.classList.remove('drag-over'));
        if (afterElement) {
          afterElement.classList.add('drag-over');
        }
      });

      DOM.imageList.addEventListener('dragleave', (e) => {
        const container = e.target.closest('.image-container');
        if (container) container.classList.remove('drag-over');
      });

      DOM.imageList.addEventListener('drop', (e) => {
        e.preventDefault();
        const containers = Array.from(DOM.imageList.querySelectorAll('.image-container'));
        const dragging = DOM.imageList.querySelector('.dragging');
        DOM.imageList.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));

        if (!dragging) return;
        const fromIndex = containers.indexOf(dragging);

        const afterElement = getDragAfterElement(DOM.imageList, e.clientY);
        let toIndex = afterElement ? containers.indexOf(afterElement) : containers.length - 1;

        if (fromIndex !== -1 && toIndex !== -1 && fromIndex !== toIndex) {
          ImageManager.reorderImages(fromIndex, toIndex);
        }
        dragging.classList.remove('dragging');
        draggedElement = null;
        dragStartIndex = null;
      });

      DOM.imageList.addEventListener('dragend', () => {
        DOM.imageList.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
        DOM.imageList.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        draggedElement = null;
        dragStartIndex = null;
      });

      // Utilitário para encontrar o elemento após o mouse
      function getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll('.image-container:not(.dragging)')];
        return draggableElements.reduce((closest, child) => {
          const box = child.getBoundingClientRect();
          const offset = y - (box.top + box.height / 2);
          if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
          } else {
            return closest;
          }
        }, { offset: -Infinity, element: null }).element;
      }

      // Eventos dos botões de seleção
      DOM.selectAllCheckbox.addEventListener('change', () => {
        const images = imageGalleryByTab.get(currentTab) || [];
        const selectedSet = selectedImagesByTab.get(currentTab);

        if (DOM.selectAllCheckbox.checked) {
          images.forEach(name => selectedSet.add(name));
        } else {
          selectedSet.clear();
        }

        UI.renderImages();
        UI.updateButtonsState();
        StateManager.saveState();
      });

      DOM.clearSelectionBtn.addEventListener('click', ImageManager.clearSelection);
      DOM.deleteSelectedBtn.addEventListener('click', ImageManager.deleteSelected);

      // Eventos dos botões de arquivo/nuvem
      DOM.openFileDialogButton.addEventListener('click', () => {
        DOM.fileInput.value = '';
        DOM.fileInput.click();
      });
      DOM.fileInput.addEventListener('change', ImageManager.handleFileSelection);

      DOM.openCloudFolderButton.addEventListener('click', () => {
        window.open(ONE_DRIVE_FOLDER_URL, '_blank');
        Utils.showStatus('Abrindo pasta do OneDrive em uma nova aba.');
      });

      // Eventos dos botões do cabeçalho
      DOM.syncBtn.addEventListener('click', () => {
        Utils.showStatus('Funcionalidade de Sincronização em desenvolvimento...');
      });

      DOM.settingsBtn.addEventListener('click', () => {
        Utils.showStatus('Funcionalidade de Configurações em desenvolvimento...');
      });
    }
  };

    // Função de inicialização
    async function init() {
      UI.showLoading();
      try {
        await IndexedDBManager.open();
        await StateManager.loadState();
        UI.createTabs();
        UI.updateTabsUI();
        await UI.renderImages();
        UI.updateButtonsState();
        EventManager.setup();
      } catch (e) {
        console.error("Erro na inicialização:", e);
        Utils.showStatus("Erro ao iniciar o aplicativo. Tente recarregar a página.");
      } finally {
        UI.hideLoading();
      }
    }

    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
